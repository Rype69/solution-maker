        /// <summary>
        /// The name of the connection string
        /// </summary>
        private const string ConnectionStringName = "IntegrationTests";

        /// <summary>
        /// Tests the <see cref="{className}Repository.FindAll" /> method.
        /// </summary>
        [TestMethod]
        public void FindAll_NoParameters_FindsAllObjects()
        {
            try
            {
                // Drop the "{className}" table if it exists already
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // Create the "{className}" table
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.CREATE TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // Create new repository
                var repository = new {className}Repository();

                // Get list of results
                var results = repository.FindAll();

                // Assert that the results is instantiated
                Assert.IsNotNull(results);

                // Assert that the results contains zero objects
                Assert.AreEqual(0, results.Count);

                // List of entities generated by the insert method
                var insertedEntities = new List<{className}>();

                // Determine the amount of records 
                var amountOfRecords = Utilities.Random.NextInt32(1, 10);

                // Insert into the table
                for (var i = 0; i < amountOfRecords; i++)
                {
                    var instance = this.Initialise{className}();
                    insertedEntities.Add(instance);
                    this.InsertRecord(instance);
                }

                // Re-select all the data
                results = repository.FindAll();

                // Assert that the results is instantiated
                Assert.IsNotNull(results);

                // Assert that the results contains the amount objects that were inserted
                Assert.AreEqual(amountOfRecords, results.Count);

                // Attempt to find the objects and assert that they are as expected
                foreach (var result in results)
                {
                    this.AssertEqualPropertyValues(insertedEntities.First(r => r.Id == result.Id), result);
                }
            }
            finally
            {
                // Drop the "{className}" table if it still exists
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);
            }
        }

        /// <summary>
        /// Tests the <see cref="{className}Repository.FindById" /> method.
        /// </summary>
        [TestMethod]
        public void FindById_GivenID_ObjectFound()
        {
            try
            {
                // Drop the "{className}" table if it exists already
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // Create the "{className}" table
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.CREATE TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // List of entities generated by the insert method
                var insertedEntities = new List<{className}>();

                // Determine the amount of records 
                var amountOfRecords = Utilities.Random.NextInt32(1, 10);

                // Insert into the table
                for (var i = 0; i < amountOfRecords; i++)
                {
                    var instance = this.Initialise{className}();
                    insertedEntities.Add(instance);
                    this.InsertRecord(instance);
                }

                // Create new repository
                var repository = new {className}Repository();

                // Attempt to find the objects
                foreach (var insertedEntity in insertedEntities)
                {
                    var retrievedEntity = repository.FindById(insertedEntity.Id);
                    Assert.IsNotNull(retrievedEntity);
                    this.AssertEqualPropertyValues(insertedEntity, retrievedEntity);
                }
            }
            finally
            {
                // Drop the "{className}" table if it still exists
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);
            }
        }

        /// <summary>
        /// Tests the <see cref="{className}Repository.Remove" /> method.
        /// </summary>
        [TestMethod]
        public void Remove_ObjectToRemove_Removed()
        {
            try
            {
                // Drop the "{className}" table if it exists already
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // Create the "{className}" table
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.CREATE TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // List of entities generated by the insert method
                var insertedEntities = new List<{className}>();

                // Determine the amount of records 
                var amountOfRecords = Utilities.Random.NextInt32(1, 10);

                // Insert into the table
                for (var i = 0; i < amountOfRecords; i++)
                {
                    var instance = this.Initialise{className}();
                    insertedEntities.Add(instance);
                    this.InsertRecord(instance);
                }

                // Select count from table, it should be equal to amountOfRecords
                var count = Utilities.Data.SqlClient.SqlCommand.RunExecuteScalar("SELECT COUNT(*) FROM [{className}];", ConnectionStringName);
                Assert.AreEqual(amountOfRecords, count);

                // Create new repository
                var repository = new {className}Repository();

                // Attempt to remove
                var removeCount = 0;
                foreach (var insertedEntity in insertedEntities)
                {
                    removeCount++;
                    repository.Remove(insertedEntity);

                    // Select count from table, it should be equal to amountOfRecords
                    var newCount = Utilities.Data.SqlClient.SqlCommand.RunExecuteScalar("SELECT COUNT(*) FROM [{className}];", ConnectionStringName);
                    Assert.AreEqual(amountOfRecords - removeCount, newCount);
                }
            }
            finally
            {
                // Drop the "{className}" table if it still exists
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);
            }
        }

        /// <summary>
        /// Tests the <see cref="{className}Repository.Save" /> method.
        /// </summary>
        [TestMethod]
        public void Save_ObjectToSave_Saved()
        {
            try
            {
                // Drop the "{className}" table if it exists already
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // Create the "{className}" table
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.CREATE TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);

                // Create a new instance
                var instance = this.Initialise{className}();

                // Create new repository
                var repository = new {className}Repository();

                // Attempt to insert the instance
                repository.Save(instance);

                // Select count from table, it should be one
                var countAfterInsert = Utilities.Data.SqlClient.SqlCommand.RunExecuteScalar("SELECT COUNT(*) FROM [{className}];", ConnectionStringName);
                Assert.AreEqual(1, countAfterInsert);

                // Re-initialise the instance
                this.Initialise{className}(instance);

                // Attempt to insert the instance
                repository.Save(instance);

                // Select count from table, it should still be one
                var countAfterUpdate = Utilities.Data.SqlClient.SqlCommand.RunExecuteScalar("SELECT COUNT(*) FROM [{className}];", ConnectionStringName);
                Assert.AreEqual(1, countAfterUpdate);
            }
            finally
            {
                // Drop the "{className}" table if it still exists
                Utilities.Data.SqlClient.SqlCommand.RunExecuteScalarFromManifestResource(this.GetType().Assembly, "RyanPenfold.TestProject.Repository.Tests.Integration.SQL.DROP TABLE [{sourceObjectSchema}].[{sourceObjectName}].sql", ConnectionStringName);
            }
        }

        /// <summary>
        /// Asserts each of the property values on each of the instances are equal.
        /// </summary>
        /// <param name="expected">Instance containing expected property values.</param>
        /// <param name="actual">Instance containing actual property values.</param>
        private void AssertEqualPropertyValues({className} expected, {className} actual)
        {
            if (expected == null)
            {
                throw new ArgumentNullException(nameof(expected));
            }

            if (actual == null)
            {
                throw new ArgumentNullException(nameof(actual));
            }

            Assert.AreEqual(expected.Id, actual.Id);
            Assert.AreEqual(expected.BigIntColumn, actual.BigIntColumn);
            Assert.AreEqual(BitConverter.ToString(expected.BinaryColumn), BitConverter.ToString(actual.BinaryColumn));
            Assert.AreEqual(expected.BitColumn, actual.BitColumn);
            Assert.AreEqual(expected.CharColumn, actual.CharColumn);
            Assert.AreEqual(expected.DateColumn, actual.DateColumn);

			if (expected.DateTimeColumn.HasValue && actual.DateTimeColumn.HasValue)
            {
                Assert.AreEqual(expected.DateTimeColumn.Value.ToString("dd/MM/yyyy HH:mm:ss"), actual.DateTimeColumn.Value.ToString("dd/MM/yyyy HH:mm:ss"));
            }

            if (expected.DateTime2Column.HasValue && actual.DateTime2Column.HasValue)
            {
                Assert.AreEqual(expected.DateTime2Column.Value.ToString("dd/MM/yyyy HH:mm:ss"), actual.DateTime2Column.Value.ToString("dd/MM/yyyy HH:mm:ss"));
            }

            if (expected.DateTimeOffsetColumn.HasValue && actual.DateTimeOffsetColumn.HasValue)
            {
                Assert.AreEqual(expected.DateTimeOffsetColumn.Value.ToString("yyyy-MM-dd HH:mm:ss %K"), actual.DateTimeOffsetColumn.Value.ToString("yyyy-MM-dd HH:mm:ss %K"));
            }

            Assert.AreEqual(expected.DecimalColumn, actual.DecimalColumn);

            if (expected.FloatColumn.HasValue && actual.FloatColumn.HasValue)
            {
                Assert.AreEqual(expected.FloatColumn.Value.ToString(CultureInfo.InvariantCulture), actual.FloatColumn.Value.ToString(CultureInfo.InvariantCulture)); // Expected:<5.53531259481185E+306>. Actual:<5.53531259481185E+306> */
            }

            Assert.AreEqual(expected.GeographyColumn, actual.GeographyColumn);
            Assert.AreEqual(expected.GeometryColumn, actual.GeometryColumn);
            Assert.AreEqual(expected.HierarchyIdColumn, actual.HierarchyIdColumn);
            Assert.AreEqual(BitConverter.ToString(expected.ImageColumn), BitConverter.ToString(actual.ImageColumn));
            Assert.AreEqual(expected.IntColumn, actual.IntColumn);
            Assert.AreEqual(expected.MoneyColumn, actual.MoneyColumn);
            Assert.AreEqual(expected.NCharColumn, actual.NCharColumn);
            Assert.AreEqual(expected.NTextColumn, actual.NTextColumn);
            Assert.AreEqual(expected.NumericColumn, actual.NumericColumn);
            Assert.AreEqual(expected.NVarCharColumn, actual.NVarCharColumn);

            if (expected.RealColumn.HasValue && actual.RealColumn.HasValue)
            {
                Assert.AreEqual(expected.RealColumn.Value.ToString(CultureInfo.InvariantCulture), actual.RealColumn.Value.ToString(CultureInfo.InvariantCulture));
            }

            Assert.AreEqual(expected.SmallDateTimeColumn, actual.SmallDateTimeColumn);
            Assert.AreEqual(expected.SmallIntColumn, actual.SmallIntColumn);
            Assert.AreEqual(expected.SmallMoneyColumn, actual.SmallMoneyColumn);
            Assert.AreEqual(expected.SqlVariantColumn, actual.SqlVariantColumn);
            Assert.AreEqual(expected.TextColumn, actual.TextColumn);
            Assert.AreEqual(expected.TimeColumn, actual.TimeColumn);
            /*Assert.AreEqual(BitConverter.ToString(expected.TimestampColumn), BitConverter.ToString(actual.TimestampColumn)); not able to test a timestamp property a specific value can't be inserted, nor can the column be updated. */
            Assert.AreEqual(expected.TinyIntColumn, actual.TinyIntColumn);
            Assert.AreEqual(expected.UniqueIdentifierColumn, actual.UniqueIdentifierColumn);
            Assert.AreEqual(BitConverter.ToString(expected.VarBinaryColumn), BitConverter.ToString(actual.VarBinaryColumn));
            Assert.AreEqual(expected.VarCharColumn, actual.VarCharColumn);
            Assert.AreEqual(expected.XmlColumn, actual.XmlColumn);
        }

        /// <summary>
        /// Creates a <see cref="{className}"/> with random property values.
        /// </summary>
        /// <param name="instance">An instance to initialise.</param>
        /// <returns>A <see cref="{className}"/>.</returns>
        private {className} Initialise{className}({className} instance = null)
        {
            if (instance == null)
            {
                instance = new {className} { Id = Guid.NewGuid() };
            }

            // TODO: In solution maker, determine the value for any optional parameters of the random methods
            instance.BigIntColumn = Utilities.Random.NextInt64();
            instance.BinaryColumn = Utilities.Random.NextBytes(50); /* Get the length from the property mapping, the default is 16 */
            instance.BitColumn = Utilities.Random.NextBoolean();
            instance.CharColumn = Utilities.Random.NextString().Replace("'", ";"); /* Get the length from the property mapping, the default is 10 */
            instance.DateColumn = Utilities.Random.NextDateTime(false);
            instance.DateTimeColumn = Utilities.Random.NextDateTime(new DateTime(1753, 1, 1), DateTime.MaxValue);
            instance.DateTime2Column = Utilities.Random.NextDateTime();
            instance.DateTimeOffsetColumn = Utilities.Random.NextDateTimeOffset();
            instance.DecimalColumn = Utilities.Random.NextInt16(-1, 1);
            instance.FloatColumn = Utilities.Random.NextDouble();
            instance.GeographyColumn = null;
            instance.GeometryColumn = null;
            instance.HierarchyIdColumn = null;
            instance.ImageColumn = Utilities.Random.NextBytes(); /* Get the length from the property mapping, the default is 16 */
            instance.IntColumn = Utilities.Random.NextInt32();
            instance.MoneyColumn = (decimal)Utilities.Random.NextDouble(-922337203685477.5808, 922337203685477.5807);
            instance.NCharColumn = Utilities.Random.NextString().Replace("'", ";"); /* Get the length from the property mapping, the default is 10 */
            instance.NTextColumn = Utilities.Random.NextString(1).Replace("'", ";");
            instance.NumericColumn = Utilities.Random.NextInt16(-1, 1);
            instance.NVarCharColumn = Utilities.Random.NextString(1).Replace("'", ";");
            instance.RealColumn = Utilities.Random.NextSingle(-0.9f, 0.9f);
            instance.SmallDateTimeColumn = Utilities.Random.NextDateTime(new DateTime(1900, 1, 1), new DateTime(2079, 6, 6), false);
            instance.SmallIntColumn = Utilities.Random.NextInt16();
            instance.SmallMoneyColumn = (decimal)Utilities.Random.NextSingle(-214748.3648f, 214748.3647f);
            instance.SqlVariantColumn = Utilities.Random.NextString(1).Replace("'", ";");
            instance.TextColumn = Utilities.Random.NextString(1).Replace("'", ";");
            instance.TimeColumn = Utilities.Random.NextTimeSpan();
            /* instance.TimestampColumn = Utilities.Random.NextBytes(8); not able to test a timestamp property a specific value can't be inserted, nor can the column be updated. */
            instance.TinyIntColumn = Utilities.Random.NextByte();
            instance.UniqueIdentifierColumn = Guid.NewGuid();
            instance.VarBinaryColumn = Utilities.Random.NextBytes(1);
            instance.VarCharColumn = Utilities.Random.NextString(1).Replace("'", ";");
            instance.XmlColumn = "<{className} />";

            return instance;
        }

        /// <summary>
        /// Inserts a record into the mapped table
        /// </summary>
        private void InsertRecord({className} entity)
        {
            // NULL-check the entity
            if (entity == null)
            {
                throw new ArgumentNullException(nameof(entity));
            }

            var sqlcommandBuilder = new System.Text.StringBuilder();

            sqlcommandBuilder.AppendWithDelimiter("INSERT INTO [{sourceObjectSchema}].[{sourceObjectName}]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("(", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("    [{sourceObjectSchema}].[{sourceObjectName}].[id]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[BigIntColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[BinaryColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[BitColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[CharColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[DateColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[DateTimeColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[DateTime2Column]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[DateTimeOffsetColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[DecimalColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[FloatColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[GeographyColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[GeometryColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[HierarchyIdColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[ImageColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[IntColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[MoneyColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[NCharColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[NTextColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[NumericColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[NVarCharColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[RealColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[SmallDateTimeColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[SmallIntColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[SmallMoneyColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[SqlVariantColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[TextColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[TimeColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[TimestampColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[TinyIntColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[UniqueIdentifierColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[VarBinaryColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[VarCharColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("   ,[{sourceObjectSchema}].[{sourceObjectName}].[XmlColumn]", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(")", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("VALUES", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter("(", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"   '{entity.Id}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.BigIntColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,0x{string.Concat(entity.BinaryColumn.Select(b => b.ToString("X2")).ToArray())}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(entity.BitColumn.HasValue ? $"  ,{Utilities.Boolean.ToByte(entity.BitColumn.Value)}" : ", NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.CharColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(entity.DateColumn.HasValue ? $"  ,'{entity.DateColumn.Value.ToString("yyyy-MM-dd")}'" : ", NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(entity.DateTimeColumn.HasValue ? $"  ,'{entity.DateTimeColumn.Value.ToString("yyyy-MM-dd HH:mm:ss")}'" : ", NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(entity.DateTime2Column.HasValue ? $"  ,'{entity.DateTime2Column.Value.ToString("yyyy-MM-dd HH:mm:ss")}'" : ", NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(entity.DateTimeOffsetColumn.HasValue ? $"  ,'{entity.DateTimeOffsetColumn.Value.ToString("yyyy-MM-dd HH:mm:ss %K")}'" : ", NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.DecimalColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.FloatColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,0x{string.Concat(entity.ImageColumn.Select(b => b.ToString("X2")).ToArray())}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.IntColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.MoneyColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.NCharColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.NTextColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.NumericColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.NVarCharColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.RealColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(entity.SmallDateTimeColumn.HasValue ? $"  ,'{entity.SmallDateTimeColumn.Value.ToString("yyyy-MM-dd HH:mm:ss")}'" : ", NULL", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.SmallIntColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,{entity.SmallMoneyColumn}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.SqlVariantColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.TextColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.TimeColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,DEFAULT", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.TinyIntColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.UniqueIdentifierColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,0x{string.Concat(entity.VarBinaryColumn.Select(b => b.ToString("X2")).ToArray())}", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.VarCharColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter($"  ,'{entity.XmlColumn}'", "\r\n");
            sqlcommandBuilder.AppendWithDelimiter(");", "\r\n");

            Utilities.Data.SqlClient.SqlCommand.RunExecuteScalar(
                sqlcommandBuilder.ToString(),
                ConnectionStringName);
        }
